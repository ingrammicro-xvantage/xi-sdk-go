/*
XI Sdk Resellers

For Resellers seeking to innovate with Ingram Micro's API solutions, automate your eCommerce experience with our array of API's and webhooks to craft a seamless journey for your customers.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package xi_sdk_resellers

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// OrdersAPIService OrdersAPI service
type OrdersAPIService service

type ApiDeleteOrdercancelRequest struct {
	ctx context.Context
	ApiService *OrdersAPIService
	orderNumber string
	iMCustomerNumber *string
	iMCountryCode *string
	iMCorrelationID *string
	regionCode *string
	iMSenderID *string
}

// Your unique Ingram Micro customer number.
func (r ApiDeleteOrdercancelRequest) IMCustomerNumber(iMCustomerNumber string) ApiDeleteOrdercancelRequest {
	r.iMCustomerNumber = &iMCustomerNumber
	return r
}

// Two-character ISO country code.
func (r ApiDeleteOrdercancelRequest) IMCountryCode(iMCountryCode string) ApiDeleteOrdercancelRequest {
	r.iMCountryCode = &iMCountryCode
	return r
}

// Unique transaction number to identify each transaction accross all the systems.
func (r ApiDeleteOrdercancelRequest) IMCorrelationID(iMCorrelationID string) ApiDeleteOrdercancelRequest {
	r.iMCorrelationID = &iMCorrelationID
	return r
}

// Region code for sandbox testing - Not for use in production.
func (r ApiDeleteOrdercancelRequest) RegionCode(regionCode string) ApiDeleteOrdercancelRequest {
	r.regionCode = &regionCode
	return r
}

// Unique value used to identify the sender of the transaction. Example: MyCompany
func (r ApiDeleteOrdercancelRequest) IMSenderID(iMSenderID string) ApiDeleteOrdercancelRequest {
	r.iMSenderID = &iMSenderID
	return r
}

func (r ApiDeleteOrdercancelRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteOrdercancelExecute(r)
}

/*
DeleteOrdercancel Cancel your Order

This call must be submitted before the order is released to Ingram Micro’s warehouse. The order cannot be canceled once it is released to the warehouse. Order should be on customer hold to delete any order from Ingram system.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orderNumber Ingram Micro sales order number.
 @return ApiDeleteOrdercancelRequest
*/
func (a *OrdersAPIService) DeleteOrdercancel(ctx context.Context, orderNumber string) ApiDeleteOrdercancelRequest {
	return ApiDeleteOrdercancelRequest{
		ApiService: a,
		ctx: ctx,
		orderNumber: orderNumber,
	}
}

// Execute executes the request
func (a *OrdersAPIService) DeleteOrdercancelExecute(r ApiDeleteOrdercancelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersAPIService.DeleteOrdercancel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resellers/v6/orders/{OrderNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"OrderNumber"+"}", url.PathEscape(parameterValueToString(r.orderNumber, "orderNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iMCustomerNumber == nil {
		return nil, reportError("iMCustomerNumber is required and must be specified")
	}
	if r.iMCountryCode == nil {
		return nil, reportError("iMCountryCode is required and must be specified")
	}
	if strlen(*r.iMCountryCode) < 2 {
		return nil, reportError("iMCountryCode must have at least 2 elements")
	}
	if strlen(*r.iMCountryCode) > 2 {
		return nil, reportError("iMCountryCode must have less than 2 elements")
	}
	if r.iMCorrelationID == nil {
		return nil, reportError("iMCorrelationID is required and must be specified")
	}
	if strlen(*r.iMCorrelationID) > 32 {
		return nil, reportError("iMCorrelationID must have less than 32 elements")
	}

	if r.regionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regionCode", r.regionCode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CustomerNumber", r.iMCustomerNumber, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CountryCode", r.iMCountryCode, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CorrelationID", r.iMCorrelationID, "simple", "")
	if r.iMSenderID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-SenderID", r.iMSenderID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetOrderdetailsV61Request struct {
	ctx context.Context
	ApiService *OrdersAPIService
	ordernumber string
	iMCustomerNumber *string
	iMCountryCode *string
	iMCorrelationID *string
	iMSenderID *string
	ingramOrderDate *string
	vendorNumber *string
	simulateStatus *string
	isIml *bool
	regionCode *string
}

// Your unique Ingram Micro customer number.
func (r ApiGetOrderdetailsV61Request) IMCustomerNumber(iMCustomerNumber string) ApiGetOrderdetailsV61Request {
	r.iMCustomerNumber = &iMCustomerNumber
	return r
}

// Two-character ISO country code.
func (r ApiGetOrderdetailsV61Request) IMCountryCode(iMCountryCode string) ApiGetOrderdetailsV61Request {
	r.iMCountryCode = &iMCountryCode
	return r
}

// Unique transaction number to identify each transaction accross all the systems.
func (r ApiGetOrderdetailsV61Request) IMCorrelationID(iMCorrelationID string) ApiGetOrderdetailsV61Request {
	r.iMCorrelationID = &iMCorrelationID
	return r
}

// Unique value used to identify the sender of the transaction. Example: MyCompany.
func (r ApiGetOrderdetailsV61Request) IMSenderID(iMSenderID string) ApiGetOrderdetailsV61Request {
	r.iMSenderID = &iMSenderID
	return r
}

// The date and time in UTC format that the order was created.
func (r ApiGetOrderdetailsV61Request) IngramOrderDate(ingramOrderDate string) ApiGetOrderdetailsV61Request {
	r.ingramOrderDate = &ingramOrderDate
	return r
}

// Vendor Number.
func (r ApiGetOrderdetailsV61Request) VendorNumber(vendorNumber string) ApiGetOrderdetailsV61Request {
	r.vendorNumber = &vendorNumber
	return r
}

// Order response for various order statuses. Not for use in production.
func (r ApiGetOrderdetailsV61Request) SimulateStatus(simulateStatus string) ApiGetOrderdetailsV61Request {
	r.simulateStatus = &simulateStatus
	return r
}

// True/False only for IML customers.
func (r ApiGetOrderdetailsV61Request) IsIml(isIml bool) ApiGetOrderdetailsV61Request {
	r.isIml = &isIml
	return r
}

// Region code for sandbox testing - Not for use in production.
func (r ApiGetOrderdetailsV61Request) RegionCode(regionCode string) ApiGetOrderdetailsV61Request {
	r.regionCode = &regionCode
	return r
}

func (r ApiGetOrderdetailsV61Request) Execute() (*OrderDetailB2B, *http.Response, error) {
	return r.ApiService.GetOrderdetailsV61Execute(r)
}

/*
GetOrderdetailsV61 Get Order Details v6.1

The Orders details API endpoint allows a customer to retrieve their Ingram Micro orders details by using the Ingram Micro sales order number as a path parameter. The sales order number, IM-CustomerNumber, IM-CountryCode, and IM-CorrelationID are required parameters.<br><br>*Service contracts, subscriptions, and license information are unavailable at the moment, this information will be available in the future. <br><br> Recent bug fixes:

 - Fixed duplication of serial numbers in the API response.

 - Fixed API time-out issues

 - Fixed missing tracking information.

 - Implemented enhanced order status.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ordernumber The Ingram Micro sales order number.
 @return ApiGetOrderdetailsV61Request
*/
func (a *OrdersAPIService) GetOrderdetailsV61(ctx context.Context, ordernumber string) ApiGetOrderdetailsV61Request {
	return ApiGetOrderdetailsV61Request{
		ApiService: a,
		ctx: ctx,
		ordernumber: ordernumber,
	}
}

// Execute executes the request
//  @return OrderDetailB2B
func (a *OrdersAPIService) GetOrderdetailsV61Execute(r ApiGetOrderdetailsV61Request) (*OrderDetailB2B, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderDetailB2B
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersAPIService.GetOrderdetailsV61")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resellers/v6.1/orders/{ordernumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"ordernumber"+"}", url.PathEscape(parameterValueToString(r.ordernumber, "ordernumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ordernumber) > 12 {
		return localVarReturnValue, nil, reportError("ordernumber must have less than 12 elements")
	}
	if r.iMCustomerNumber == nil {
		return localVarReturnValue, nil, reportError("iMCustomerNumber is required and must be specified")
	}
	if strlen(*r.iMCustomerNumber) > 10 {
		return localVarReturnValue, nil, reportError("iMCustomerNumber must have less than 10 elements")
	}
	if r.iMCountryCode == nil {
		return localVarReturnValue, nil, reportError("iMCountryCode is required and must be specified")
	}
	if strlen(*r.iMCountryCode) < 2 {
		return localVarReturnValue, nil, reportError("iMCountryCode must have at least 2 elements")
	}
	if strlen(*r.iMCountryCode) > 2 {
		return localVarReturnValue, nil, reportError("iMCountryCode must have less than 2 elements")
	}
	if r.iMCorrelationID == nil {
		return localVarReturnValue, nil, reportError("iMCorrelationID is required and must be specified")
	}
	if strlen(*r.iMCorrelationID) > 32 {
		return localVarReturnValue, nil, reportError("iMCorrelationID must have less than 32 elements")
	}

	if r.ingramOrderDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ingramOrderDate", r.ingramOrderDate, "form", "")
	}
	if r.vendorNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendorNumber", r.vendorNumber, "form", "")
	}
	if r.simulateStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "simulateStatus", r.simulateStatus, "form", "")
	}
	if r.isIml != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIml", r.isIml, "form", "")
	}
	if r.regionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regionCode", r.regionCode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CustomerNumber", r.iMCustomerNumber, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CountryCode", r.iMCountryCode, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CorrelationID", r.iMCorrelationID, "simple", "")
	if r.iMSenderID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-SenderID", r.iMSenderID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResellersV6OrdersearchRequest struct {
	ctx context.Context
	ApiService *OrdersAPIService
	iMCustomerNumber *string
	iMCountryCode *string
	iMCorrelationID *string
	ingramOrderNumber *string
	orderStatus *string
	orderStatusIn *[]string
	ingramOrderDate *string
	ingramOrderDateBt *[]string
	iMSenderID *string
	customerOrderNumber *string
	pageSize *int32
	pageNumber *int32
	endCustomerOrderNumber *string
	invoiceDateBt *[]string
	shipDateBt *[]string
	deliveryDateBt *[]string
	ingramPartNumber *string
	vendorPartNumber *string
	serialNumber *string
	trackingNumber *string
	vendorName *string
	specialBidNumber *string
}

// Your unique Ingram Micro customer number.
func (r ApiGetResellersV6OrdersearchRequest) IMCustomerNumber(iMCustomerNumber string) ApiGetResellersV6OrdersearchRequest {
	r.iMCustomerNumber = &iMCustomerNumber
	return r
}

// Two-character ISO country code.
func (r ApiGetResellersV6OrdersearchRequest) IMCountryCode(iMCountryCode string) ApiGetResellersV6OrdersearchRequest {
	r.iMCountryCode = &iMCountryCode
	return r
}

// Unique transaction number to identify each transaction accross all the systems.
func (r ApiGetResellersV6OrdersearchRequest) IMCorrelationID(iMCorrelationID string) ApiGetResellersV6OrdersearchRequest {
	r.iMCorrelationID = &iMCorrelationID
	return r
}

// The Ingram Micro order number.
func (r ApiGetResellersV6OrdersearchRequest) IngramOrderNumber(ingramOrderNumber string) ApiGetResellersV6OrdersearchRequest {
	r.ingramOrderNumber = &ingramOrderNumber
	return r
}

// Ingram Micro order status.
func (r ApiGetResellersV6OrdersearchRequest) OrderStatus(orderStatus string) ApiGetResellersV6OrdersearchRequest {
	r.orderStatus = &orderStatus
	return r
}

// Ingram Micro order status(can use it for multiple entries).
func (r ApiGetResellersV6OrdersearchRequest) OrderStatusIn(orderStatusIn []string) ApiGetResellersV6OrdersearchRequest {
	r.orderStatusIn = &orderStatusIn
	return r
}

// Search by Order date(yyyy-MM-dd).
func (r ApiGetResellersV6OrdersearchRequest) IngramOrderDate(ingramOrderDate string) ApiGetResellersV6OrdersearchRequest {
	r.ingramOrderDate = &ingramOrderDate
	return r
}

// Search with the start and end date(only 2 entries allowed).
func (r ApiGetResellersV6OrdersearchRequest) IngramOrderDateBt(ingramOrderDateBt []string) ApiGetResellersV6OrdersearchRequest {
	r.ingramOrderDateBt = &ingramOrderDateBt
	return r
}

// Unique value used to identify the sender of the transaction. Example: MyCompany
func (r ApiGetResellersV6OrdersearchRequest) IMSenderID(iMSenderID string) ApiGetResellersV6OrdersearchRequest {
	r.iMSenderID = &iMSenderID
	return r
}

// Search using your PO/Order number.
func (r ApiGetResellersV6OrdersearchRequest) CustomerOrderNumber(customerOrderNumber string) ApiGetResellersV6OrdersearchRequest {
	r.customerOrderNumber = &customerOrderNumber
	return r
}

// The number of records required in the call - max records 100 per page.
func (r ApiGetResellersV6OrdersearchRequest) PageSize(pageSize int32) ApiGetResellersV6OrdersearchRequest {
	r.pageSize = &pageSize
	return r
}

// The page number reference.
func (r ApiGetResellersV6OrdersearchRequest) PageNumber(pageNumber int32) ApiGetResellersV6OrdersearchRequest {
	r.pageNumber = &pageNumber
	return r
}

// End customer/user purchase order number.
func (r ApiGetResellersV6OrdersearchRequest) EndCustomerOrderNumber(endCustomerOrderNumber string) ApiGetResellersV6OrdersearchRequest {
	r.endCustomerOrderNumber = &endCustomerOrderNumber
	return r
}

// Invoice date of order, search with the start and end date(only 2 entries allowed).*Currently, this feature is not available in Australia.
func (r ApiGetResellersV6OrdersearchRequest) InvoiceDateBt(invoiceDateBt []string) ApiGetResellersV6OrdersearchRequest {
	r.invoiceDateBt = &invoiceDateBt
	return r
}

// Shipment date of order, search with the start and end date(only 2 entries allowed).
func (r ApiGetResellersV6OrdersearchRequest) ShipDateBt(shipDateBt []string) ApiGetResellersV6OrdersearchRequest {
	r.shipDateBt = &shipDateBt
	return r
}

// The delivery date of the order, search with the start and end date(only 2 entries allowed).*Currently, this feature is not available in Australia
func (r ApiGetResellersV6OrdersearchRequest) DeliveryDateBt(deliveryDateBt []string) ApiGetResellersV6OrdersearchRequest {
	r.deliveryDateBt = &deliveryDateBt
	return r
}

// Ingram Micro unique part number for the product.
func (r ApiGetResellersV6OrdersearchRequest) IngramPartNumber(ingramPartNumber string) ApiGetResellersV6OrdersearchRequest {
	r.ingramPartNumber = &ingramPartNumber
	return r
}

// Vendor’s part number for the product.
func (r ApiGetResellersV6OrdersearchRequest) VendorPartNumber(vendorPartNumber string) ApiGetResellersV6OrdersearchRequest {
	r.vendorPartNumber = &vendorPartNumber
	return r
}

// A serial number of the product.
func (r ApiGetResellersV6OrdersearchRequest) SerialNumber(serialNumber string) ApiGetResellersV6OrdersearchRequest {
	r.serialNumber = &serialNumber
	return r
}

// The tracking number of the order.*Currently, this feature is not available in Australia
func (r ApiGetResellersV6OrdersearchRequest) TrackingNumber(trackingNumber string) ApiGetResellersV6OrdersearchRequest {
	r.trackingNumber = &trackingNumber
	return r
}

// Name of the vendor.
func (r ApiGetResellersV6OrdersearchRequest) VendorName(vendorName string) ApiGetResellersV6OrdersearchRequest {
	r.vendorName = &vendorName
	return r
}

// The bid number provided to the reseller by the vendor for special pricing and discounts. Line-level bid numbers take precedence over header-level bid numbers.*Currently, this feature is not available in Australia
func (r ApiGetResellersV6OrdersearchRequest) SpecialBidNumber(specialBidNumber string) ApiGetResellersV6OrdersearchRequest {
	r.specialBidNumber = &specialBidNumber
	return r
}

func (r ApiGetResellersV6OrdersearchRequest) Execute() (*OrderSearchResponse, *http.Response, error) {
	return r.ApiService.GetResellersV6OrdersearchExecute(r)
}

/*
GetResellersV6Ordersearch Search your Orders

The Orders Search API endpoint allows a customer to search their Ingram Micro orders by using any of the available query string parameters, customer can search their order by using single query string parameters or combining them together. This endpoint supports the pagination of results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetResellersV6OrdersearchRequest
*/
func (a *OrdersAPIService) GetResellersV6Ordersearch(ctx context.Context) ApiGetResellersV6OrdersearchRequest {
	return ApiGetResellersV6OrdersearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderSearchResponse
func (a *OrdersAPIService) GetResellersV6OrdersearchExecute(r ApiGetResellersV6OrdersearchRequest) (*OrderSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersAPIService.GetResellersV6Ordersearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resellers/v6/orders/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iMCustomerNumber == nil {
		return localVarReturnValue, nil, reportError("iMCustomerNumber is required and must be specified")
	}
	if strlen(*r.iMCustomerNumber) > 10 {
		return localVarReturnValue, nil, reportError("iMCustomerNumber must have less than 10 elements")
	}
	if r.iMCountryCode == nil {
		return localVarReturnValue, nil, reportError("iMCountryCode is required and must be specified")
	}
	if strlen(*r.iMCountryCode) < 2 {
		return localVarReturnValue, nil, reportError("iMCountryCode must have at least 2 elements")
	}
	if strlen(*r.iMCountryCode) > 2 {
		return localVarReturnValue, nil, reportError("iMCountryCode must have less than 2 elements")
	}
	if r.iMCorrelationID == nil {
		return localVarReturnValue, nil, reportError("iMCorrelationID is required and must be specified")
	}
	if strlen(*r.iMCorrelationID) > 32 {
		return localVarReturnValue, nil, reportError("iMCorrelationID must have less than 32 elements")
	}

	if r.ingramOrderNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ingramOrderNumber", r.ingramOrderNumber, "form", "")
	}
	if r.orderStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderStatus", r.orderStatus, "form", "")
	}
	if r.orderStatusIn != nil {
		t := *r.orderStatusIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderStatus-in", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderStatus-in", t, "form", "multi")
		}
	}
	if r.ingramOrderDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ingramOrderDate", r.ingramOrderDate, "form", "")
	}
	if r.ingramOrderDateBt != nil {
		t := *r.ingramOrderDateBt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ingramOrderDate-bt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ingramOrderDate-bt", t, "form", "multi")
		}
	}
	if r.customerOrderNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customerOrderNumber", r.customerOrderNumber, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	}
	if r.endCustomerOrderNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endCustomerOrderNumber", r.endCustomerOrderNumber, "form", "")
	}
	if r.invoiceDateBt != nil {
		t := *r.invoiceDateBt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceDate_bt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceDate_bt", t, "form", "multi")
		}
	}
	if r.shipDateBt != nil {
		t := *r.shipDateBt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipDate_bt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipDate_bt", t, "form", "multi")
		}
	}
	if r.deliveryDateBt != nil {
		t := *r.deliveryDateBt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deliveryDate_bt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deliveryDate_bt", t, "form", "multi")
		}
	}
	if r.ingramPartNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ingramPartNumber", r.ingramPartNumber, "form", "")
	}
	if r.vendorPartNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendorPartNumber", r.vendorPartNumber, "form", "")
	}
	if r.serialNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", r.serialNumber, "form", "")
	}
	if r.trackingNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackingNumber", r.trackingNumber, "form", "")
	}
	if r.vendorName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendorName", r.vendorName, "form", "")
	}
	if r.specialBidNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "specialBidNumber", r.specialBidNumber, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CustomerNumber", r.iMCustomerNumber, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CountryCode", r.iMCountryCode, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CorrelationID", r.iMCorrelationID, "simple", "")
	if r.iMSenderID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-SenderID", r.iMSenderID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateorderV6Request struct {
	ctx context.Context
	ApiService *OrdersAPIService
	iMCustomerNumber *string
	iMCountryCode *string
	iMCorrelationID *string
	orderCreateRequest *OrderCreateRequest
	iMSenderID *string
}

// Your unique Ingram Micro customer number.
func (r ApiPostCreateorderV6Request) IMCustomerNumber(iMCustomerNumber string) ApiPostCreateorderV6Request {
	r.iMCustomerNumber = &iMCustomerNumber
	return r
}

// Two-character ISO country code.
func (r ApiPostCreateorderV6Request) IMCountryCode(iMCountryCode string) ApiPostCreateorderV6Request {
	r.iMCountryCode = &iMCountryCode
	return r
}

// Unique transaction number to identify each transaction accross all the systems.
func (r ApiPostCreateorderV6Request) IMCorrelationID(iMCorrelationID string) ApiPostCreateorderV6Request {
	r.iMCorrelationID = &iMCorrelationID
	return r
}

func (r ApiPostCreateorderV6Request) OrderCreateRequest(orderCreateRequest OrderCreateRequest) ApiPostCreateorderV6Request {
	r.orderCreateRequest = &orderCreateRequest
	return r
}

// Unique value used to identify the sender of the transaction. Example: MyCompany
func (r ApiPostCreateorderV6Request) IMSenderID(iMSenderID string) ApiPostCreateorderV6Request {
	r.iMSenderID = &iMSenderID
	return r
}

func (r ApiPostCreateorderV6Request) Execute() (*OrderCreateResponse, *http.Response, error) {
	return r.ApiService.PostCreateorderV6Execute(r)
}

/*
PostCreateorderV6 Create your Order

Instantly create and place orders. The POST API supports stocked SKUs as well as licensing and warranties SKUs.
IM-CustomerNumber, IM-CountryCode, IM-SenderID and IM-CorrelationID are required parameters.
Ingram Micro recommends that you provide the ingrampartnumber for each SKU contained in each order.
NOTE: You must have net terms to use the Ingram Micro Order Create API. Ingram Micro offers trade credit when using our APIs, and repayment is based on net terms. For example, if your net terms agreement is net-30, you will have 30 days to make a full payment. Ingram Micro does not allow credit card transactions for API ordering. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateorderV6Request
*/
func (a *OrdersAPIService) PostCreateorderV6(ctx context.Context) ApiPostCreateorderV6Request {
	return ApiPostCreateorderV6Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderCreateResponse
func (a *OrdersAPIService) PostCreateorderV6Execute(r ApiPostCreateorderV6Request) (*OrderCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersAPIService.PostCreateorderV6")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resellers/v6/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iMCustomerNumber == nil {
		return localVarReturnValue, nil, reportError("iMCustomerNumber is required and must be specified")
	}
	if strlen(*r.iMCustomerNumber) > 10 {
		return localVarReturnValue, nil, reportError("iMCustomerNumber must have less than 10 elements")
	}
	if r.iMCountryCode == nil {
		return localVarReturnValue, nil, reportError("iMCountryCode is required and must be specified")
	}
	if strlen(*r.iMCountryCode) < 2 {
		return localVarReturnValue, nil, reportError("iMCountryCode must have at least 2 elements")
	}
	if strlen(*r.iMCountryCode) > 2 {
		return localVarReturnValue, nil, reportError("iMCountryCode must have less than 2 elements")
	}
	if r.iMCorrelationID == nil {
		return localVarReturnValue, nil, reportError("iMCorrelationID is required and must be specified")
	}
	if strlen(*r.iMCorrelationID) > 32 {
		return localVarReturnValue, nil, reportError("iMCorrelationID must have less than 32 elements")
	}
	if r.orderCreateRequest == nil {
		return localVarReturnValue, nil, reportError("orderCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CustomerNumber", r.iMCustomerNumber, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CountryCode", r.iMCountryCode, "simple", "")
	if r.iMSenderID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-SenderID", r.iMSenderID, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CorrelationID", r.iMCorrelationID, "simple", "")
	// body params
	localVarPostBody = r.orderCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateorderV7Request struct {
	ctx context.Context
	ApiService *OrdersAPIService
	iMCustomerNumber *string
	iMCountryCode *string
	iMCorrelationID *string
	orderCreateV7Request *OrderCreateV7Request
	iMSenderID *string
}

// Your unique Ingram Micro customer number.
func (r ApiPostCreateorderV7Request) IMCustomerNumber(iMCustomerNumber string) ApiPostCreateorderV7Request {
	r.iMCustomerNumber = &iMCustomerNumber
	return r
}

// Two-character ISO country code.
func (r ApiPostCreateorderV7Request) IMCountryCode(iMCountryCode string) ApiPostCreateorderV7Request {
	r.iMCountryCode = &iMCountryCode
	return r
}

// Unique transaction number to identify each transaction across all the systems.
func (r ApiPostCreateorderV7Request) IMCorrelationID(iMCorrelationID string) ApiPostCreateorderV7Request {
	r.iMCorrelationID = &iMCorrelationID
	return r
}

func (r ApiPostCreateorderV7Request) OrderCreateV7Request(orderCreateV7Request OrderCreateV7Request) ApiPostCreateorderV7Request {
	r.orderCreateV7Request = &orderCreateV7Request
	return r
}

// Unique value used to identify the sender of the transaction. Example: MyCompany
func (r ApiPostCreateorderV7Request) IMSenderID(iMSenderID string) ApiPostCreateorderV7Request {
	r.iMSenderID = &iMSenderID
	return r
}

func (r ApiPostCreateorderV7Request) Execute() (*OrderCreateV7Response201, *http.Response, error) {
	return r.ApiService.PostCreateorderV7Execute(r)
}

/*
PostCreateorderV7 Create your Order v7

The Order Create v7 allows our customers to create orders asynchronously. The customer can create either standard orders using stocked SKUs and/or create a “Quote to Order” using the existing quote which is in “Ready to Order” status, or the customer can create an order using the “Configure to order” (CTO) quote. Upon successful submission of the order create request, a confirmation message will be returned as an API response. <br > <br > Once the order is processed, Ingram Micro will notify customers via webhook using a pre-defined callback URL as an HTTP post regarding the updates related to the order. Upon successful order creation, a notification will be sent via webhook regarding the order details, in the event of any error occurring during the order creation process, an error message will be delivered via webhook. Nightly system unavailability will delay response Async response. <br > <br > The key differentiator between standard ordering and “Quote To Order” is the optional input field in the request body which is “quoteNumber”. If a customer passes the quote number in the request body, the order will be processed as a “Quote To Order” using the details from the quote. Any SKUs, quantity, or price information that are passed in the lines object within the request will be ignored in the case of “Quote To Order”.<br > <br > **Prerequisite:** Pre-defined callback URL <br > <br > **Standard ordering::**<br><br>Ingram Micro recommends that you provide the ingramPartNumber for each SKU contained in each order. NOTE: You must have net terms to use the Ingram Micro Order Create API. Ingram Micro offers trade credit when using our APIs, and repayment is based on net terms. For example, if your net terms agreement is net 30, you will have 30 days to make a full payment. Ingram Micro does not allow credit card transactions for API ordering. <br><br>[**Key differences between v6 and v7 Migration**](https://developer.ingrammicro.com/reseller/page/v6-and-v7-migration) <br><br> <br><br>**Quote to Order / Configure to Order:**<br><br>If customers are planning to use Quote to Order or Configure to Order Quotes, it’s recommended to validate the quote using the “Validate Quote” endpoint before creating an order using the quote. Validate Quote endpoint will not only validate the quote but also outline all the mandatory fields required by the vendor at a header level and at the line level which a customer needs to pass to the Quote to Order endpoint request. For a detailed understanding of the “Validate Quote” endpoint, review the “Validate Quote” endpoint documentation. <br><br> **How it works:**<br><br>- The customer validates the quote with a quote number from the Validate Quote endpoint.<br>- The customer copies all the mandatory fields required by the vendor and adds them to the QTO request body.<br>- The customer provides all the values for Vendor mandatory fields along with other required information for QTO to create an order.<br>- After the order creation request receipt acknowledgment from the QTO endpoint, all further order creation updates will be provided via webhook push notification.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateorderV7Request
*/
func (a *OrdersAPIService) PostCreateorderV7(ctx context.Context) ApiPostCreateorderV7Request {
	return ApiPostCreateorderV7Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderCreateV7Response201
func (a *OrdersAPIService) PostCreateorderV7Execute(r ApiPostCreateorderV7Request) (*OrderCreateV7Response201, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderCreateV7Response201
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersAPIService.PostCreateorderV7")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resellers/v7/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iMCustomerNumber == nil {
		return localVarReturnValue, nil, reportError("iMCustomerNumber is required and must be specified")
	}
	if strlen(*r.iMCustomerNumber) > 10 {
		return localVarReturnValue, nil, reportError("iMCustomerNumber must have less than 10 elements")
	}
	if r.iMCountryCode == nil {
		return localVarReturnValue, nil, reportError("iMCountryCode is required and must be specified")
	}
	if strlen(*r.iMCountryCode) < 2 {
		return localVarReturnValue, nil, reportError("iMCountryCode must have at least 2 elements")
	}
	if strlen(*r.iMCountryCode) > 2 {
		return localVarReturnValue, nil, reportError("iMCountryCode must have less than 2 elements")
	}
	if r.iMCorrelationID == nil {
		return localVarReturnValue, nil, reportError("iMCorrelationID is required and must be specified")
	}
	if strlen(*r.iMCorrelationID) > 32 {
		return localVarReturnValue, nil, reportError("iMCorrelationID must have less than 32 elements")
	}
	if r.orderCreateV7Request == nil {
		return localVarReturnValue, nil, reportError("orderCreateV7Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CustomerNumber", r.iMCustomerNumber, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CountryCode", r.iMCountryCode, "simple", "")
	if r.iMSenderID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-SenderID", r.iMSenderID, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CorrelationID", r.iMCorrelationID, "simple", "")
	// body params
	localVarPostBody = r.orderCreateV7Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v PostCreateorderV7400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v PostCreateorderV7500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutOrdermodifyRequest struct {
	ctx context.Context
	ApiService *OrdersAPIService
	orderNumber string
	iMCustomerNumber *string
	iMCountryCode *string
	iMCorrelationID *string
	orderModifyRequest *OrderModifyRequest
	actionCode *string
	regionCode *string
	iMSenderID *string
}

// Your unique Ingram Micro customer number.
func (r ApiPutOrdermodifyRequest) IMCustomerNumber(iMCustomerNumber string) ApiPutOrdermodifyRequest {
	r.iMCustomerNumber = &iMCustomerNumber
	return r
}

// Two-character ISO country code.
func (r ApiPutOrdermodifyRequest) IMCountryCode(iMCountryCode string) ApiPutOrdermodifyRequest {
	r.iMCountryCode = &iMCountryCode
	return r
}

// Unique transaction number to identify each transaction across all the systems.
func (r ApiPutOrdermodifyRequest) IMCorrelationID(iMCorrelationID string) ApiPutOrdermodifyRequest {
	r.iMCorrelationID = &iMCorrelationID
	return r
}

func (r ApiPutOrdermodifyRequest) OrderModifyRequest(orderModifyRequest OrderModifyRequest) ApiPutOrdermodifyRequest {
	r.orderModifyRequest = &orderModifyRequest
	return r
}

// Action code to be used for order release.
func (r ApiPutOrdermodifyRequest) ActionCode(actionCode string) ApiPutOrdermodifyRequest {
	r.actionCode = &actionCode
	return r
}

// Region code paramter to be used only for order release functionality.Region code is only for sandbox not for production
func (r ApiPutOrdermodifyRequest) RegionCode(regionCode string) ApiPutOrdermodifyRequest {
	r.regionCode = &regionCode
	return r
}

// Unique value used to identify the sender of the transaction. Example: MyCompany
func (r ApiPutOrdermodifyRequest) IMSenderID(iMSenderID string) ApiPutOrdermodifyRequest {
	r.iMSenderID = &iMSenderID
	return r
}

func (r ApiPutOrdermodifyRequest) Execute() (*OrderModifyResponse, *http.Response, error) {
	return r.ApiService.PutOrdermodifyExecute(r)
}

/*
PutOrdermodify Modify your Order

The Order Modify API endpoint allows for changes to be made to an order after the order creation process as long as the order was created with the customer hold flag.

* Orders can be modified within 24hrs of being placed with the customer hold flag, after 24hrs they are voided if they are not released by the customer.

* Modifying orders that were placed without the customer hold flag is not possible 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orderNumber Ingram sales order number.
 @return ApiPutOrdermodifyRequest
*/
func (a *OrdersAPIService) PutOrdermodify(ctx context.Context, orderNumber string) ApiPutOrdermodifyRequest {
	return ApiPutOrdermodifyRequest{
		ApiService: a,
		ctx: ctx,
		orderNumber: orderNumber,
	}
}

// Execute executes the request
//  @return OrderModifyResponse
func (a *OrdersAPIService) PutOrdermodifyExecute(r ApiPutOrdermodifyRequest) (*OrderModifyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderModifyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersAPIService.PutOrdermodify")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resellers/v6/orders/{orderNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"orderNumber"+"}", url.PathEscape(parameterValueToString(r.orderNumber, "orderNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iMCustomerNumber == nil {
		return localVarReturnValue, nil, reportError("iMCustomerNumber is required and must be specified")
	}
	if strlen(*r.iMCustomerNumber) > 10 {
		return localVarReturnValue, nil, reportError("iMCustomerNumber must have less than 10 elements")
	}
	if r.iMCountryCode == nil {
		return localVarReturnValue, nil, reportError("iMCountryCode is required and must be specified")
	}
	if strlen(*r.iMCountryCode) < 2 {
		return localVarReturnValue, nil, reportError("iMCountryCode must have at least 2 elements")
	}
	if strlen(*r.iMCountryCode) > 2 {
		return localVarReturnValue, nil, reportError("iMCountryCode must have less than 2 elements")
	}
	if r.iMCorrelationID == nil {
		return localVarReturnValue, nil, reportError("iMCorrelationID is required and must be specified")
	}
	if strlen(*r.iMCorrelationID) > 32 {
		return localVarReturnValue, nil, reportError("iMCorrelationID must have less than 32 elements")
	}
	if r.orderModifyRequest == nil {
		return localVarReturnValue, nil, reportError("orderModifyRequest is required and must be specified")
	}

	if r.actionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionCode", r.actionCode, "form", "")
	}
	if r.regionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regionCode", r.regionCode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CustomerNumber", r.iMCustomerNumber, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CountryCode", r.iMCountryCode, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-CorrelationID", r.iMCorrelationID, "simple", "")
	if r.iMSenderID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "IM-SenderID", r.iMSenderID, "simple", "")
	}
	// body params
	localVarPostBody = r.orderModifyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
